from pymongo import MongoClient
import sys
import random
import math
import functools
import bisect
from bson import json_util
import json
import pymysql
import datetime

TESTNAME="1";
EXPERIMENT = 3; # 1-6
SEED = 1;
SIZE = 1000;
FUZZYMIN = 0.25;
FUZZYMAX = 0.75 ;
DOMAINMIN = sys.maxint;
DOMAINMAX = sys.maxint;
IMPRECISIONMIN = 0.0;
IMPRECISIONMAX = DOMAINMAX/1000;
NODES=5; #4+router+config

# Abre conexion con la base de datos
db = pymysql.connect("35.233.40.167","root","a1rpagz2","experimental")
#db = pymysql.connect("127.0.0.1","root","a1rpagz2","sql-experiments")

# prepare a cursor object using cursor() method
cursor = db.cursor()


#deberia controlar la memoria??? 512
#cpuNum mejor a double si no recordar que esta en porcentaje
#zone deberia ser un TEXT
sql = "INSERT INTO Environment (nodesNum, machineType, cpuNum, diskType, zone)" \
      " VALUES (%s, %s, %s, %s, %s)"
val = (NODES,"n1-standard-2",25,"SSD","eu-west1-b")
cursor.execute(sql, val)
db.commit()
idEnv=cursor.lastrowid
print idEnv


sql = "INSERT INTO Query (type, time, timelast, resultsNum, seed, numQueries)" \
      " VALUES (%s, %s, %s, %s, %s, %s)"
val = ("FEQ",datetime.datetime.now(),datetime.datetime.now(),0,SEED,1)
cursor.execute(sql, val)
db.commit()
idQue=cursor.lastrowid
print idQue


sql = "INSERT INTO Dbase (seed, size, fuzzyficationMin, fuzzyficationMax, imprecisionMin, imprecisionMax, domainMin, domainMax)" \
      " VALUES (%s,%s,%s,%s, %s, %s, %s, %s)"
val = (SEED,SIZE,FUZZYMIN,FUZZYMAX,IMPRECISIONMIN,IMPRECISIONMAX,DOMAINMIN,DOMAINMAX)
cursor.execute(sql, val)
db.commit()
idDab=cursor.lastrowid
print idDab




sql = "INSERT INTO test (name, createdAt, updatedAt, idExperiment, idEnvironment, idDbase, idQuery)" \
      " VALUES (%s, %s, %s, %s, %s, %s, %s)"
val = (TESTNAME,datetime.datetime.now(),datetime.datetime.now(),EXPERIMENT,idEnv,idDab,idQue)
cursor.execute(sql, val)
db.commit()
idTest=cursor.lastrowid
print idTest



client = MongoClient("mongodb://main_admin:abc123@localhost:27017")

mydb = client["mydatabase"]
client.admin.command('enableSharding', 'mydatabase')
#NO PARA STANDALONE
mycol = mydb["mytest"]


random.seed(SEED)

class ZipfGenerator:

    def __init__(self, n, alpha):
        # Calculate Zeta values from 1 to n:
        tmp = [1. / (math.pow(float(i), alpha)) for i in range(1, n + 1)]
        zeta = functools.reduce(lambda sums, x: sums + [sums[-1] + x], tmp, [0])

        # Store the translation map:
        self.distMap = [x / zeta[-1] for x in zeta]

    def next(self):
        # Take a uniform 0-1 pseudo-random value:
        u = random.random()

        # Translate the Zipf variable:
        return bisect.bisect(self.distMap, u) - 1


zipf = ZipfGenerator(SIZE, 1) #10000???


def randomTrap():
    # Point is the geometric center of trapezoid

    point = random.uniform(-DOMAINMIN, DOMAINMAX)

    # Width of trapezoid (using zipf distribution)

    width = zipf.next() * random.uniform(IMPRECISIONMIN, IMPRECISIONMAX)

    # Adapt tilt if we want an angle more opened or not

    tilt = random.uniform(FUZZYMIN, FUZZYMAX)

    # Creating trapezoid a,b,c,d

    a = point - width / 2

    d = point + width / 2

    if (d < a):
        aux = d
        d = a
        a = aux

    b = point - tilt * (width / 2)

    c = point + tilt * (width / 2)

    if (c < b):
        aux = c
        c = b
        b = aux

    return [a, b, c, d]


def randDoc(id):
    x = randomTrap()
    post = {"_id": id, "x": x}
    post["x"]
    return post


for i in xrange(SIZE):
    mydict = randDoc(i)
    n = mycol.insert_one(mydict)

timesql= datetime.date.now()

myquery = {"$where:'feq(this.x,[]) >=0.5'"}
mydoc = mycol.find(myquery).explain("executionStats")

sql = "UPDATE Query SET time = %s WHERE id = %s"
val = (timesql, idQue)
cursor.execute(sql, val)
mydb.commit()

sql = "UPDATE Query SET timelast = %s WHERE id = %s"
val = (datetime.date.now(), idQue)
cursor.execute(sql, val)
mydb.commit()

sql = "UPDATE Test SET updatedAt = %s WHERE id = %s"
val = (datetime.date.now(), idTest)
cursor.execute(sql, val)
mydb.commit()


#Get the file name for the new file to write
filename = TESTNAME

# If the file name exists, write a JSON string into the file.
if filename:
    # Writing JSON data
    with open(filename, 'w') as f:
        json_util.dumps(mydoc,f)


# desconecta del servidor SQL
db.close()