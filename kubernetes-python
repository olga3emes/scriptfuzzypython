from pymongo import MongoClient
import sys
import random
import math
import functools
import bisect
from bson import json_util
import json
import bson
import pymysql
import datetime

SEED = sys.argv[1];
print "Seed: " + SEED
QUERYSEED = sys.argv[2];
print "Query-Seed: " + QUERYSEED


TESTNAME="Test " + SEED;
EXPERIMENT = 3; # 1-6
NODES=5; #4+router+config

#---------------- Database --------------------------
SIZE = 1000;

FUZZYMIN = 0.25;
FUZZYMAX = 0.75 ;
DOMAINMIN = sys.maxint;
DOMAINMAX = sys.maxint;
IMPRECISIONMIN = 0.0;
IMPRECISIONMAX = DOMAINMAX/1000;

#---------------- Queries -----------------------------
NUMQUERIES = 2;

FUZZYMINQ = 0.25;
FUZZYMAXQ = 0.75 ;
DOMAINMINQ = sys.maxint;
DOMAINMAXQ = sys.maxint;
IMPRECISIONMINQ = 0.0;
IMPRECISIONMAXQ = DOMAINMAX/1000;

TYPE= "feq";
OPERATION='>=';
REQUIREMENTLEVEL=random.randrange(0,1,0.1)


# Abre conexion con la base de datos
db = pymysql.connect("35.233.40.167","root","a1rpagz2","experimental")
#db = pymysql.connect("127.0.0.1","root","a1rpagz2","sql-experiments")

# prepare a cursor object using cursor() method
cursor = db.cursor()


#memoria GB
#cpuNum double
sql = "INSERT INTO Environment (nodesNum, machineType, cpuNum, ramMemory, diskType, zone)" \
      " VALUES (%s, %s, %s, %s, %s, %s)"
val = (NODES,"n1-standard-2",0.25,0.5,"SSD","europe-west1-b")
cursor.execute(sql, val)
db.commit()
idEnv=cursor.lastrowid
print idEnv


sql = "INSERT INTO Dbase (seed, size, fuzzyficationMin, fuzzyficationMax, imprecisionMin, imprecisionMax, domainMin, domainMax)" \
      " VALUES (%s,%s,%s,%s, %s, %s, %s, %s)"
val = (SEED,SIZE,FUZZYMIN,FUZZYMAX,IMPRECISIONMIN,IMPRECISIONMAX,DOMAINMIN,DOMAINMAX)
cursor.execute(sql, val)
db.commit()
idDab=cursor.lastrowid
print idDab


sql = "INSERT INTO QuerySet (type, totalTime, seed, numQueries, fuzzyficationMin, fuzzyficationMax, imprecisionMin, imprecisionMax, domainMin, domainMax)" \
      " VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
val = (TYPE,0,0,QUERYSEED,NUMQUERIES,FUZZYMINQ,FUZZYMAXQ,IMPRECISIONMINQ,IMPRECISIONMAXQ,DOMAINMINQ,DOMAINMAXQ)
cursor.execute(sql, val)
db.commit()
idQuerySet=cursor.lastrowid
print idQuerySet



sql = "INSERT INTO Test (name, createdAt, updatedAt, idExperiment, idEnvironment, idDbase, idQuerySet)" \
      " VALUES (%s, %s, %s, %s, %s, %s, %s)"
val = (TESTNAME,datetime.datetime.now(),datetime.datetime.now(),EXPERIMENT,idEnv,idDab,idQuerySet)
cursor.execute(sql, val)
db.commit()
idTest=cursor.lastrowid
print idTest



client = MongoClient("mongodb://main_admin:abc123@localhost:27017")

mydb = client["mydatabase"]
mycol = mydb["mytest"]
mycol.delete_many({})
client.admin.command('enableSharding', 'mydatabase')
#NO PARA STANDALONE



random.seed(SEED)

class ZipfGenerator:

    def __init__(self, n, alpha):
        # Calculate Zeta values from 1 to n:
        tmp = [1. / (math.pow(float(i), alpha)) for i in range(1, n + 1)]
        zeta = functools.reduce(lambda sums, x: sums + [sums[-1] + x], tmp, [0])

        # Store the translation map:
        self.distMap = [x / zeta[-1] for x in zeta]

    def next(self):
        # Take a uniform 0-1 pseudo-random value:
        u = random.random()

        # Translate the Zipf variable:
        return bisect.bisect(self.distMap, u) - 1


def randomTrap(domainMin, domainMax, imprecisionMin, imprecisionMax, fuzzyMin, fuzzyMax, numTrap):


    zipf = ZipfGenerator(numTrap, 1)
    # Point is the geometric center of trapezoid

    point = random.uniform(domainMin,domainMax)

    # Width of trapezoid (using zipf distribution)

    width = zipf.next() * random.uniform(imprecisionMin, imprecisionMax)

    # Adapt tilt if we want an angle more opened or not

    tilt = random.uniform(fuzzyMin, fuzzyMax)

    # Creating trapezoid a,b,c,d

    a = point - width / 2

    d = point + width / 2

    if (d < a):
        aux = d
        d = a
        a = aux

    b = point - tilt * (width / 2)

    c = point + tilt * (width / 2)

    if (c < b):
        aux = c
        c = b
        b = aux

    return [a, b, c, d]


def randDoc(id):
    x = randomTrap(-DOMAINMIN,DOMAINMAX,IMPRECISIONMIN,IMPRECISIONMAX,FUZZYMIN,FUZZYMAX,SIZE)
    post = {"_id": id, "x": x}
    post["x"]
    return post


for i in xrange(SIZE):
    mydict = randDoc(i)
    n = mycol.insert_one(mydict)



for i in xrange(NUMQUERIES):
    sql = "INSERT INTO Query (order, idQuerySet, resultsNum, time, operation, requirementLevel)" \
          " VALUES (%s,%s,%s,%s, %s, %s)"
    val = (i, idQuerySet, 0, 0, OPERATION, REQUIREMENTLEVEL)
    cursor.execute(sql, val)
    db.commit()
    idQue = cursor.lastrowid
    print "id Query:" +idQue
    random.random(QUERYSEED)
    y=randomTrap(-DOMAINMINQ,DOMAINMAXQ,IMPRECISIONMINQ,IMPRECISIONMAXQ,FUZZYMINQ,FUZZYMAXQ,NUMQUERIES)
    myquery = {"$where:'"+TYPE+"(this.x,'"+y+") "+ OPERATION,REQUIREMENTLEVEL}
    mydoc = list(mycol.find(myquery))
    mydoc2= client.admin.command(
        bson.son.SON([('explain',bson.son.SON([('find', 'mycol'), ('filter', {'$where' : TYPE+'(this.x,'+y+')'+OPERATION+REQUIREMENTLEVEL})])), ('verbosity', 'executionStats')]))
    print mydoc
    print mydoc2
    print mydoc2.executionTimeMillis
    timeMillis=mydoc2.exectionTimeMillis

    sql = "UPDATE QuerySet SET totalTime += %s WHERE id = %s"
    val = (timeMillis, idQuerySet)
    cursor.execute(sql, val)
    db.commit()

    sql = "UPDATE Query SET resultsNum = %s WHERE id = %s"
    val = (len(mydoc), idQue)
    cursor.execute(sql, val)
    db.commit()

    sql = "UPDATE Query SET time = %s WHERE id = %s"
    val = (timeMillis, idQue)
    cursor.execute(sql, val)
    db.commit()

sql = "UPDATE Test SET updatedAt = %s WHERE id = %s"
val = (datetime.datetime.now(), idTest)
cursor.execute(sql, val)
db.commit()



# desconecta del servidor SQL
db.close()
#desconecta mongo
client.close()